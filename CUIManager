CUIManager = class()

--每个窗口需要定义自己的层级类型
--不同层级的窗口有不同的基础规则（定制规则可以用参数控制），也就是层级是一类大的通用规则的分类
--FullScreen层级：窗口之间互斥(因为全屏窗口同时只可能有一个是可见的),
WindowLayer = {
	FullScreen = 1,--全屏
	Popup = 2,--弹出框,
	MassegeBox = 3,--对话框
	Tips = 4,
	System = 5
}

function CUIManager:ctor()
	
	--[[行为队列：tCommandQueue
		由于窗口的打开是一个过程（包括资源的异步加载和动画过程），
		所以在同一帧连续调用ShowWindow是没法同时进行的，需要排队.
		不然的话会造成同时Show两个不同的窗口时，实际的打开顺序依赖于谁的资源加载的快（回调先回来），而造成混乱。
		应该为谁先调用谁先被打开.
		同时，在同一时间show和close一个窗口会发生什么行为？如果不加入队列，也是不可控的。
	]]
	self.tCommandQueue = {}
	self.CommandType = {
		Show = 1,
		Close = 2,
	}
	
	--窗口的实例缓存
	self.WindowInstanceMap = {}
	
	--
	self.WindowStackList = {
		
	}
	
	--“正在打开”的窗口(因为第一次加载窗口资源是异步的)
	--self.OpeningWindow = nil
	--当前活动的Win
	self.ActivedWin = nil
end


--Public:

--[[打开一个对话框:
	strWinID：要打开的窗口
	winArg：传递给窗口的参数
	showArg:控制窗口显示的参数
]]
function CUIManager:ShowWindow(strWinID,winArg,tShowArg)
	
	--插入处理队列
	local tShowCommand = {
		WinID = strWinID,
		WinArg = winArg,
		ShowArg = tShowArg,
		CommandType = self.CommandType.Show
	}
	table.insert(tCommandQueue,tShowCommand)
	
	--如果当前处理队列还有没结束的任务，退出，等待当前任务执行完再去执行
	if #tCommandQueue > 1 then
		DEBUG_LOG("CUIManager:ShowWindow","Can Not Show Window When Another WinCommand Is Doing:",strWinID,tCommandQueue[1].WinID)
		return
	end
	
	self:ProcessCommand(tShowCommand)
end


--获取当“可见”的的窗口列表
function CUIManager:GetVisibleWindows()
	
	local tWinIDList= {}
	
	for _,tWindowStack in ipairs(self.WindowStackList) do
		local nLenth = #tWindowStack
		if nLenth > 0 then
			table.insert(tWinIDList,tWindowStack[nLenth])
		end
	end
	
	return tWinIDList
end

--获取当“活动的”的窗口列表
function CUIManager:GetActivedWindow()
	return self.ActivedWin
end

--刷新当前可见的win
function CUIManager:RefreshWin(strWinID,winArg,tShowArg)
	
	local tWinClassInstance = self:getWinClassInstance(strWinID)
	if tWinClassInstance == nil then
		return
	end
	
	if not tWinClassInstance:IsVisible() then
		return
	end
	
	--do someing here
end


--private:

--获取对话框的“类”（CUIBase实例）
function CUIManager:getWinClassInstance(strWinID)
	local tWinClassInstance = self.WindowInstanceMap[strWinID]
	
	if tWinClassInstance == nil then
		local tModuleType = ModuleType[strWinID]
		local strClassName = tModuleType.ClassName
		require ("src/game/views/" .. strClassName)
		
		if _G[strClassName] == nil then
			DEBUG_LOG("CUIManager:ShowDialog","Can Not Find Window Class:",strWinID,strClassName)
		else
			tWinClassInstance = _G[strClassName]()--是这样实例化吗？
			self.WindowInstanceMap[strWinID] = tWinClassInstance
			--tWinClassInstance:Init()--暂时不需要，类的初始化在构造函数就可以了
			
			--这里自动将窗口id保存在各自窗口的实例中
			tWinClassInstance.ModuleTypeID = strWinID
		end
	end
	
	return tWinClassInstance
end


function CUIManager:processCommand(tCommand)
	
	if tCommand.CommandType == self.CommandType.Show then
		self:processShowCommand(tCommand)
	elseif tCommand.CommandType == self.CommandType.Close then
		self:processCloseCommand(tCommand)
	else
		DEBUG_LOG("CUIManager:ShowDialog","Can Not Process No Defined Command Type:",tCommand.CommandType)
	end
end


function CUIManager:processShowCommand(tShowCommand)
	
	local strWinID = tShowCommand.WinID
	local tShowArg = tShowCommand.ShowArg
	local winArg = tShowCommand.WinArg

	--查找对话框定义
	local ModuleType = ModuleType
	local tModuleType = ModuleType[strWinID]
	if tModuleType == nil then
		DEBUG_LOG("CUIManager:ShowWindow","Can Not Find Window Define:",strWinID)
		return 
	end
	
	--获取并检测对话框关联的类实例
	local tWinClassInstance = self:getWinClassInstance(strWinID)
	if tWinClassInstance == nil then
		return
	end
	
	--如果有窗口处于“正在打开”的过程中，这时候不允许再打开一个窗口。也就是说，不能同时打开两个窗口。
	--[[if self.OpeningWindow ~= nil then
		DEBUG_LOG("CUIManager:ShowWindow","Can Not Open Tow Window Same Time:",self.OpeningWindow)
		return
	end--]]
	
	--对于当前“可见的”窗口，不需要重新打开
	local tVisibleWinList = self:GetVisibleWindows()
	for _,strActivedID in ipairs(tVisibleWinList) do
		if strActivedID == strWinID then
			DEBUG_LOG("CUIManager:ShowWindow","This Win Is Actived:",strWinID)
			--需要重新刷一下吗？
			--self:RefreshWin(strWinID,winArg,tShowArg)
			return
		end
	end
	
end


function CUIManager:processCloseCommand(tCloseCommand)

end



